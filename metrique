#!/usr/bin/python
# vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4
# Author: "Chris Ward <cward@redhat.com>

'''
CLI for deploying metrique
'''

import datetime
from functools import partial
import getpass
import glob
import importlib
import multiprocessing
import os
import random
import re
import signal
import shlex
import shutil
import socket
import string
import subprocess
import sys
import virtualenv

virtenv_activated = False
logger = virtualenv.Logger([(0, sys.stdout)])
call_subprocess = virtualenv.call_subprocess


def deactivate():
    try:
        system('deactivate')
    except OSError:
        pass


def activate(args=None):
    global virtenv_activated

    if virtenv_activated:
        return
    elif (hasattr(args, 'virtenv') and args.virtenv):
        virtenv = args.virtenv
    elif isinstance(args, basestring):
        # virtenv path is passed in direct as a string
        virtenv = args
    else:
        virtenv = os.environ.get('VIRTUAL_ENV')

    if virtenv:
        activate_this = os.path.join(virtenv, 'bin', 'activate_this.py')
        if os.path.exists(activate_this):
            execfile(activate_this, dict(__file__=activate_this))
            virtenv_activated = True
            logger.info('Virtual Env (%s): Activated' % virtenv)


def rand_chars(size=6, chars=string.ascii_uppercase + string.digits):
    # see: http://stackoverflow.com/questions/2257441
    return ''.join(random.choice(chars) for x in range(size))


# Activate the virtual environment in this python session if
# parent env has one set
activate()

__pkgs__ = ['metrique', 'metriqued', 'metriquec', 'metriqueu',
            'metriquet', 'plotrique']
__actions__ = ['build', 'sdist', 'install', 'develop', 'register',
               'bump', 'status']
__bumps__ = ['x', 'y', 'z', 'r']
RE_VERSION_X = re.compile(r"__version__\s+=\s+[\"']((\d+).\d+.\d+)[\"']")
RE_VERSION_Y = re.compile(r"__version__\s+=\s+[\"'](\d+.(\d+).\d+)[\"']")
RE_VERSION_Z = re.compile(r"__version__\s+=\s+[\"'](\d+.\d+.(\d+))[\"']")
RE_RELEASE = re.compile(r"__release__ = [\"']?((\d+)a?)[\"']?")

RPM_SYSTEM_RELEASE = "/etc/system-release"
RPMS = ['git', 'python', 'python-devel', 'python-setuptools', 'python-pip',
        'supervisor', 'vim', 'screen', 'psmisc', 'net-tools', 'rng-tools',
        'ntp', 'mlocate', 'tar', 'pigz', 'rsync',
        'gcc', 'gcc-c++', 'gcc-gfortran', 'freetype-devel', 'libpng-devel',
        'mongodb', 'mongodb-server', 'nginx', 'krb5-devel', 'postgresql',
        'postgresql-devel']

HERE = os.getcwd()
USER = getpass.getuser()
VIRTUAL_ENV = os.environ.get('VIRTUAL_ENV', '')
NOW = datetime.datetime.utcnow().strftime('%FT%H%M%S')

HOSTNAME = socket.gethostname()
try:
    # try to get one of the local inet device ip addresses
    LOCAL_IP = socket.gethostbyname(HOSTNAME)
except Exception:
    LOCAL_IP = '127.0.0.1'

GIT_DIR = os.environ.get('METRIQUE_GIT', HERE)

SRC_DIR = os.path.join(GIT_DIR, 'src/')

# if HOME environment variable is set, use that
# useful to overide when running 'as user' with root (supervisord)
HOME_DIR = os.environ.get('HOME', os.path.expanduser('~/'))
USER_DIR = os.path.join(HOME_DIR, '.metrique')

logger.warn('-'*30)
logger.warn('Started at  : %s' % NOW)
logger.warn('Current User: %s' % USER)
logger.warn('Current CWD : %s' % HERE)
logger.warn('Virtual Env : %s' % VIRTUAL_ENV)
logger.warn('Hostname    : %s' % HOSTNAME)
logger.warn('Local IP    : %s' % LOCAL_IP)
logger.warn('GIT Repo    : %s' % GIT_DIR)
logger.warn('Source Path : %s' % SRC_DIR)
logger.warn('This file   : %s' % __file__)
logger.warn('Home Path   : %s' % HOME_DIR)
logger.warn('User Path   : %s' % USER_DIR)
logger.warn('-'*30)

if not (os.path.exists(SRC_DIR) or
        os.path.exists(os.path.join(SRC_DIR, '.git'))):
    raise OSError("can't find metrique src/ path; `export METRIQUE_GIT=...`?")

# set cache dir so pip doesn't have to keep downloading over and over
PIP_DIR = os.path.join(USER_DIR, '.pip')
PIP_CACHE_DIR = os.path.join(PIP_DIR, 'download-cache')
PIP_ACCEL_DIR = os.path.join(USER_DIR, '.pip-accel')
PIP_EGGS = os.path.join(USER_DIR, '.python-eggs')
os.environ['PIP_DOWNLOAD_CACHE'] = PIP_CACHE_DIR
os.environ['PIP_ACCEL_CACHE'] = PIP_ACCEL_DIR
os.environ['PYTHON_EGG_CACHE'] = PIP_EGGS

TRASH_DIR = os.path.join(USER_DIR, 'trash')
LOG_DIR = os.path.join(USER_DIR, 'logs')
ETC_DIR = os.path.join(USER_DIR, 'etc')
PID_DIR = os.path.join(USER_DIR, 'pids')
BACKUP_DIR = os.path.join(USER_DIR, 'backup')
TEMP_DIR = os.path.join(USER_DIR, 'tmp')
CACHE_DIR = os.path.join(USER_DIR, 'cache')
MONGODB_DIR = os.path.join(USER_DIR, 'mongodb')
CELERY_DIR = os.path.join(USER_DIR, 'celery')
GNUPG_DIR = os.path.join(USER_DIR, 'gnupg')

STATIC_PATH = os.path.join(SRC_DIR, 'metriqued/metriqued/static/')
API_DOCS_PATH = os.path.join(GIT_DIR, 'docs/build/html/')

SYS_FIRSTBOOT_PATH = os.path.join(USER_DIR, '.firstboot_sys')

METRIQUED_FIRSTBOOT_PATH = os.path.join(USER_DIR, '.firstboot_metriqued')
METRIQUED_JSON = os.path.join(ETC_DIR, 'metriqued.json')
METRIQUE_JSON = os.path.join(ETC_DIR, 'metrique.json')

PASSWORD = rand_chars(10)
COOKIE_SECRET = rand_chars(50)

SSL_CERT = os.path.join(ETC_DIR, 'metrique.crt')
SSL_KEY = os.path.join(ETC_DIR, 'metrique.key')
SSL_PEM = os.path.join(ETC_DIR, 'metrique.pem')

MONGODB_FIRSTBOOT_PATH = os.path.join(USER_DIR, '.firstboot_mongodb')
MONGODB_CONF = os.path.join(ETC_DIR, 'mongodb.conf')
MONGODB_PIDFILE = os.path.join(PID_DIR, 'mongodb.pid')
MONGODB_LOCKFILE = os.path.join(MONGODB_DIR, 'mongodb.lock')
MONGODB_LOG = os.path.join(LOG_DIR, 'mongodb.log')
MONGODB_JSON = os.path.join(ETC_DIR, 'mongodb.json')
MONGODB_JS = os.path.join(ETC_DIR, 'mongodb.js')
MONGODB_KEYFILE = os.path.join(ETC_DIR, 'mongodb.key')

CELERY_JSON = os.path.join(ETC_DIR, 'celery.json')
CELERYD_PIDFILE = os.path.join(PID_DIR, 'celeryd.pid')
CELERYBEAT_PIDFILE = os.path.join(PID_DIR, 'celerybeat.pid')
CELERY_LOGFILE = os.path.join(LOG_DIR, 'celeryd.log')

NGINX_CONF = os.path.join(ETC_DIR, 'nginx.conf')
NGINX_ACCESS_LOG = os.path.join(LOG_DIR, 'nginx_access.log')
NGINX_ERROR_LOG = os.path.join(LOG_DIR, 'nginx_error.log')
NGINX_PIDFILE = os.path.join(PID_DIR, 'nginx.pid')

SUPERVISORD_CONF = os.path.join(ETC_DIR, 'supervisord.conf')
SUPERVISORD_PIDFILE = os.path.join(PID_DIR, 'supervisord.pid')
SUPERVISORD_LOGFILE = os.path.join(LOG_DIR, 'supervisord.log')
SUPERVISORD_HISTORYFILE = os.path.join(TEMP_DIR, 'supervisord_history')

DEFAULT_METRIQUE_JSON = '''
{
    "auto_login": false,
    "batch_size": 5000,
    "cube_autoregister": false,
    "debug": true,
    "host": "127.0.0.1",
    "log2file": true,
    "logstdout": false,
    "max_workers": %s,
    "password": "%s",
    "port": 5420,
    "sql_batch_size": 1000,
    "ssl": false,
    "ssl_verify": false
}
''' % (multiprocessing.cpu_count(), PASSWORD)
DEFAULT_METRIQUE_JSON = DEFAULT_METRIQUE_JSON.strip()

DEFAULT_METRIQUED_JSON = '''
{
    "api_docs": "%s",
    "cookie_secret": "%s",
    "debug": true,
    "host": "127.0.0.1",
    "host_LOCAL": "%s",
    "krb_auth": false,
    "log2file": true,
    "logstdout": false,
    "log_requests": false,
    "port": 5420,
    "realm": "metrique",
    "ssl": false,
    "ssl_certificate": "%s",
    "ssl_certificate_key": "%s",
    "superusers": ["admin", "%s"]
}
''' % (API_DOCS_PATH, COOKIE_SECRET, LOCAL_IP,
       SSL_CERT, SSL_KEY, USER)
DEFAULT_METRIQUED_JSON = DEFAULT_METRIQUED_JSON.strip()

DEFAULT_MONGODB_JSON = '''
{
    "auth": false,
    "root_password": "%s",
    "admin_password": "%s",
    "data_password": "%s",
    "host": "127.0.0.1",
    "journal": true,
    "port": 27017,
    "ssl": false,
    "ssl_certificate": "%s",
    "write_concern": 1
}
''' % (PASSWORD, PASSWORD, PASSWORD, SSL_PEM)
DEFAULT_MONGODB_JSON = DEFAULT_MONGODB_JSON.strip()

DEFAULT_MONGODB_CONF = '''
fork = true
nohttpinterface = true
dbpath = %s
logpath = %s
pidfilepath = %s

#auth = true
noauth = true

bind_ip = 127.0.0.1
#bind_ip = %s

#sslOnNormalPorts = true
#sslPEMKeyFile = %s

#replSet = rs0
#keyFile = %s
''' % (MONGODB_DIR, MONGODB_LOG, MONGODB_PIDFILE, LOCAL_IP,
       SSL_PEM, MONGODB_KEYFILE)
DEFAULT_MONGODB_CONF = DEFAULT_MONGODB_CONF.strip()

DEFAULT_MONGODB_JS = '''
db = db.getSiblingDB('admin')
db.addUser({'user': 'root', 'pwd': '%s', 'roles': ['dbAdminAnyDatabase',
           'userAdminAnyDatabase', 'clusterAdmin', 'readWriteAnyDatabase']});
db.addUser({'user': 'admin', 'pwd': '%s', 'roles': ['dbAdminAnyDatabase',
           'userAdminAnyDatabase', 'readWriteAnyDatabase']});
db.addUser({'user': 'metrique', 'pwd': '%s', 'roles': ['readAnyDatabase']});
''' % (PASSWORD, PASSWORD, PASSWORD)
DEFAULT_MONGODB_JS = DEFAULT_MONGODB_JS.strip()

DEFAULT_CELERY_JSON = '''
{
    "BROKER_URL": "mongodb://admin:%s@127.0.0.1:27017",
    "BROKER_URL_LOCAL": "mongodb://admin:%s@%s:27017",
    "BROKER_USE_SSL": false
}
''' % (PASSWORD, PASSWORD, LOCAL_IP)
DEFAULT_CELERY_JSON = DEFAULT_CELERY_JSON.strip()

DEFAULT_NGINX_CONF = '''
worker_processes auto;

daemon on;  # turn off to avoid forking on startup (supervisord)
# see warnings: http://wiki.nginx.org/CoreModule#daemon

user %s

error_log %s;
pid %s;

events {
    worker_connections 1024;
    use epoll;
}

http {
    charset utf-8;
    client_max_body_size 0;  # disabled
    client_body_temp_path  %s 1 2;
    client_header_buffer_size 256k;
    large_client_header_buffers 8 1024k;

    proxy_temp_path   %s  1 2;
    proxy_cache_path  %s  levels=1:2     keys_zone=proxy_one:10m;

    fastcgi_temp_path   %s  1 2;
    fastcgi_cache_path  %s  levels=1:2   keys_zone=fastcgi_one:10m;

    uwsgi_temp_path   %s  1 2;
    uwsgi_cache_path  %s  levels=1:2     keys_zone=uwsgi_one:10m;

    scgi_temp_path   %s  1 2;
    scgi_cache_path  %s  levels=1:2     keys_zone=scgi_one:10m;

    # Enumerate all the Tornado servers here
    upstream frontends {
        server 127.0.0.1:5421;
        server 127.0.0.1:5422;
        server 127.0.0.1:5423;
        server 127.0.0.1:5424;
        #server %s:5421;
        #server %s:5422;
        #server %s:5423;
        #server %s:5424;
    }

    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    error_log %s;
    access_log %s;

    # Timeouts
    keepalive_timeout 3m;
    client_header_timeout  3m;
    client_body_timeout  3m;
    proxy_connect_timeout 3m;
    proxy_send_timeout 3m;
    proxy_read_timeout 3m;

    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    gzip on;
    gzip_min_length 1000;
    gzip_proxied any;
    gzip_types text/plain text/css text/xml
               application/x-javascript application/xml
               application/atom+xml text/javascript
               application/json;

    # Only retry if there was a communication error, not a timeout
    # on the Tornado server (to avoid propagating "queries of death"
    # to all frontends)
    proxy_next_upstream error;

    server {
        listen %s:5420;
        ssl                 off;
        ssl_certificate     %s;
        ssl_certificate_key %s;

        ssl_protocols        SSLv3 TLSv1 TLSv1.1 TLSv1.2;
        ssl_ciphers RC4:HIGH:!aNULL:!MD5;
        ssl_prefer_server_ciphers on;
        ssl_session_cache    shared:SSL:10m;
        ssl_session_timeout  60m;

        location ^~ /static/ {
            root %s;
            if ($query_string) {
                expires max;
            }
        }

        location / {
            proxy_pass_header Server;
            proxy_set_header Host $http_host;
            proxy_redirect off;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Scheme $scheme;
            proxy_pass http://frontends;

            proxy_set_header        Accept-Encoding   "";
            proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;

            ### Most PHP, Python, Rails, Java App can use this header ###
            #proxy_set_header X-Forwarded-Proto https;##
            #This is better##
            proxy_set_header        X-Forwarded-Proto $scheme;
            add_header              Front-End-Https   on;

            ### force timeouts if one of backend is died ##
            proxy_next_upstream error timeout invalid_header http_500 http_502
                                                             http_503 http_504;
        }
    }
}
''' % (USER, NGINX_ERROR_LOG, NGINX_PIDFILE, TEMP_DIR,
       TEMP_DIR, CACHE_DIR, TEMP_DIR, CACHE_DIR, TEMP_DIR, CACHE_DIR,
       TEMP_DIR, CACHE_DIR, LOCAL_IP, LOCAL_IP, LOCAL_IP, LOCAL_IP,
       NGINX_ERROR_LOG, NGINX_ACCESS_LOG, LOCAL_IP, SSL_CERT, SSL_KEY,
       STATIC_PATH)
DEFAULT_NGINX_CONF = DEFAULT_NGINX_CONF.strip()

ENVIRONMENT = 'VIRTUAL_ENV="%s", HOME="%s", METRIQUE_GIT="%s"' % (
    VIRTUAL_ENV, HOME_DIR, GIT_DIR)
PYTHON = os.path.join(VIRTUAL_ENV, 'bin/python')
METRIQUE = os.path.join(VIRTUAL_ENV, 'bin/metrique')
VIZTRIQUE = os.path.join(VIRTUAL_ENV, 'bin/viztriqued')
DEFAULT_SUPERVISORD_CONF = '''
[inet_http_server]
port=127.0.0.1:9001
;port=%s:9001
username=admin
password=%s

[rpcinterface:supervisor]
supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface

[supervisord]
logfile=%s
pidfile=%s
childlogdir=%s
user=%s
directory=%s
environment=%s
loglevel=debug

[supervisorctl]
serverurl=http://127.0.0.1:9001
;serverurl=http://%s:9001
username=admin
password=%s
history_file=%s

[program:mongodb]
command=%s mongodb start --nofork
process_name=mongodb
numprocs=1
priority=10
startsecs=60
stopwaitsecs=60

[program:metriqued]
command=%s metriqued start -P5421 --nofork
process_name=metriqued-%%(process_num)d
numprocs=4
priority=20
startsecs=60
startretries=5

[program:nginx]
command=%s nginx start --nofork
process_name=nginx
numprocs=1
priority=30
startsecs=30

[program:celeryd]
command=%s celeryd start --nofork
process_name=celeryd
numprocs=1
priority=40
startsecs=30

[program:celerybeat]
command=%s celerybeat start --nofork
process_name=celerybeat
numprocs=1
priority=41
startsecs=30

[program:viztriqued]
command=%s start --nofork
directory=path/to/viztrique/git/repo
process_name=viztrique
numprocs=1
priority=100
''' % (LOCAL_IP, PASSWORD, SUPERVISORD_LOGFILE, SUPERVISORD_PIDFILE,
       LOG_DIR, USER, GIT_DIR, ENVIRONMENT,
       LOCAL_IP, PASSWORD, SUPERVISORD_HISTORYFILE,
       METRIQUE, METRIQUE, METRIQUE, METRIQUE, METRIQUE, VIZTRIQUE)
DEFAULT_SUPERVISORD_CONF = DEFAULT_SUPERVISORD_CONF.strip()


def get_pid(pidfile):
    try:
        return int(''.join(open(pidfile).readlines()).strip())
    except IOError:
        return 0


def makedirs(path, mode=0700):
    if not path.startswith('/'):
        raise OSError("requires absolute path! got %s" % path)
    if not os.path.exists(path):
        os.makedirs(path, mode)
    return path


def remove(path):
    if isinstance(path, (list, tuple)):
        [remove(p) for p in path]
    else:
        assert isinstance(path, basestring)
        if os.path.exists(path):
            if os.path.isdir(path):
                shutil.rmtree(path)
            else:
                os.remove(path)


def system(cmd, fork=False, sig=None, sig_func=None):
    if sig and sig_func:
        signal.signal(sig, sig_func)

    logger.debug("Running: %s" % cmd)
    cmd = cmd.split()
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    text = p.stdout.read()
    return text


def run(cmd, cwd, show_stdout):
    cwd = cwd or SRC_DIR
    logger.info("[%s] Running ...\n`%s`" % (cwd, ' '.join(cmd)))
    try:
        call_subprocess(cmd, cwd=cwd, show_stdout=show_stdout)
    except KeyboardInterrupt:
        logger.warn('CTRL-C killed')
        sys.exit(1)
    except Exception as e:
        raise OSError('[%s] %s' % (e, ' '.join(cmd)))


def call(cmd, cwd=None, show_stdout=True, fork=False, pidfile=None,
         sig=None, sig_func=None):
    cmd = shlex.split(cmd.strip())
    if sig and sig_func:
        signal.signal(sig, sig_func)

    if fork:
        pid = os.fork()
        if pid == 0:
            run(cmd, cwd, show_stdout)
        elif pidfile:
            with open(pidfile, 'w') as f:
                f.write(str(pid))
    else:
        run(cmd, cwd, show_stdout)
    logger.info(" ... Done!")


def adjust_options(options, args):
    options.no_site_packages = True
virtualenv.adjust_options = adjust_options


def backup(saveas, path):
    gzip = system('which pigz') or system('which gzip')
    cmd = 'tar -c --use-compress-program=%s -f %s %s' % (gzip, saveas, path)
    system(cmd)


def backup_clean(args, path, prefix):
    keep = args.keep if args.keep != 0 else 3
    path = os.path.join(path, prefix) + '*'
    files = sorted(glob.glob(path), reverse=True)
    to_remove = files[keep:]
    logger.debug('Removing %i backups' % len(to_remove))
    [remove(f) for f in to_remove]


def terminate(pidfile, sig=signal.SIGTERM):
    if os.path.exists(pidfile):
        pid = get_pid(pidfile)
        try:
            os.kill(pid, sig)
        except OSError:
            logger.warn("%s not found" % pid)
        else:
            logger.warn("%s killed" % pid)
        remove(pidfile)
    else:
        logger.warn("%s does not exist" % pidfile)


def celeryd_terminate(sig=None, frame=None):
    terminate(CELERYD_PIDFILE)
    sys.exit(2)


def celeryd_loop(args):
    fork = not args.nofork
    x = 'worker'
    logfile = '--logfile=%s' % CELERY_LOGFILE
    loglvl = '-l INFO'
    pidfile = '--pidfile=%s' % CELERYD_PIDFILE
    app = '-A %s' % args.tasks_mod
    cmd = 'celery %s %s %s %s %s' % (x, logfile, loglvl, pidfile, app)
    call(cmd, fork=fork, sig=signal.SIGTERM, sig_func=celeryd_terminate)


def celeryd_task(args):
    tasks = importlib.import_module(args.tasks_mod)
    task = getattr(tasks, args.task)
    return task.run()


def celeryd(args):
    if args.command == "start":
        celeryd_loop(args)
    elif args.command == "stop":
        terminate(CELERYD_PIDFILE)
    elif args.command == "clean":
        remove(CELERYD_PIDFILE)
    else:
        raise ValueError("unknown command %s" % args.command)


def celerybeat_terminate(sig=None, frame=None):
    terminate(CELERYBEAT_PIDFILE)
    sys.exit(2)


def celerybeat_run(args):
    fork = not args.nofork
    x = 'beat'
    logfile = '--logfile=%s' % CELERY_LOGFILE
    loglvl = '-l INFO'
    pidfile = '--pidfile=%s' % CELERYBEAT_PIDFILE
    app = '-A %s' % args.tasks_mod
    cmd = 'celery %s %s %s %s %s' % (x, logfile, loglvl, pidfile, app)
    call(cmd, fork=fork, sig=signal.SIGTERM, sig_func=celerybeat_terminate)


def celerybeat(args):
    if args.command == "start":
        celerybeat_run(args)
    elif args.command == "stop":
        terminate(CELERYBEAT_PIDFILE)
    elif args.command == "clean":
        remove(CELERYBEAT_PIDFILE)
    else:
        raise ValueError("unknown command %s" % args.command)


def supervisord_terminate(sig=None, frame=None):
    terminate(SUPERVISORD_PIDFILE)
    sys.exit(2)


def supervisord_run(args):
    cmd = 'supervisord -c %s' % SUPERVISORD_CONF
    call(cmd, fork=True, sig=signal.SIGTERM, sig_func=supervisord_terminate)


def supervisord(args):
    if args.command == "start":
        supervisord_run(args)
    elif args.command == "stop":
        terminate(SUPERVISORD_PIDFILE)
    elif args.command == "clean":
        remove(SUPERVISORD_PIDFILE)
    else:
        raise ValueError("unknown command %s" % args.command)


def _metrique_user_register():
    from metrique import pyclient
    m = pyclient()
    m.user_register()


def _metriqued_firstboot(args):
    if os.path.exists(METRIQUED_FIRSTBOOT_PATH):
        return
    args.command = 'start'
    metriqued(args)
    _metrique_user_register()
    with open(METRIQUED_FIRSTBOOT_PATH, 'w') as f:
        f.write(NOW)
    args.command = 'stop'
    metriqued(args)


def _metriqued_stop(args):
    from metriqueu.utils import get_pids
    running = get_pids(PID_DIR)
    sig = args.signal or signal.SIGTERM
    for pid in running:
        print "Sending signal (%s) to (%s)" % (sig, pid)
        os.kill(pid, sig)


def _metriqued_start(args):
    # A) there are no instances currently running
    # B) there are instances running; add additional
    from metriqued.tornadohttp import MetriqueHTTP
    from metriqueu.utils import get_pids

    config_file = args.server_config_file
    pids = []
    port = args.port
    fork = not args.nofork
    instances = args.instances or 0

    if instances > 1:
        # we want to start more than one instance, we must fork
        for k in range(instances):
            pid = os.fork()
            if pid == 0:
                running_k = len(get_pids(PID_DIR))
                port = port + running_k
                metriqued = MetriqueHTTP(config_file=config_file, port=port)
                metriqued.start()
                sys.exit()
            else:
                pids.append(pid)
            port += 1
    else:
        metriqued = MetriqueHTTP(config_file=config_file, port=port)
        metriqued.start(fork=fork)
    print 'Started: %s' % ', '.join(map(str, pids))


def metriqued_backup(args):
    hosts_dir = '/etc/hosts'
    to_backup = [ETC_DIR, hosts_dir]

    for path in to_backup:
        prefix = 'metriqued.%s' % os.path.basename(path)
        saveas = '__'.join((prefix, HOSTNAME, NOW)) + '.tar.gz'
        saveas = os.path.join(BACKUP_DIR, saveas)
        backup(saveas, path)
        backup_clean(args, BACKUP_DIR, prefix)
        if args.scp_export:
            user = args.scp_user
            host = args.scp_host
            out_dir = args.scp_out_dir
            cmd = 'scp %s %s@%s:%s' % (saveas, user, host, out_dir)
            call(cmd)


def metriqued(args):
    '''
    START, STOP, RESTART, RELOAD,
    '''
    # needed by metriqued_* commands
    from metriqueu.utils import get_pids

    cmd = args.command

    if not args.instances:
        args.instances = 1

    if cmd == 'start':
        _metriqued_start(args)
    elif cmd == 'stop':
        _metriqued_stop(args)
    elif cmd == 'status':
        print 'RUNNING: %s' % ', '.join(map(str, get_pids(PID_DIR)))
    elif args.command == 'firstboot':
        _metriqued_firstboot(args)
    else:
        raise SystemExit('bad command "%s"... Try --help' % cmd)


def nginx_terminate(sig=None, frame=None):
    terminate(NGINX_PIDFILE)
    sys.exit(2)


def nginx(args):
    fork = not args.nofork
    cmd = 'nginx -c %s' % NGINX_CONF
    if args.command == 'test':
        call('%s -t' % cmd)
    elif args.command == 'start':
        call(cmd, fork=fork, sig=signal.SIGTERM, sig_func=nginx_terminate)
    elif args.command == 'stop':
        call('%s -s stop' % cmd)
    elif args.command == 'restart':
        for cmd in ('stop', 'start'):
            args.command = cmd
            nginx(args)
    elif args.command == 'reload':
        call('%s -s reload' % cmd)
    else:
        raise ValueError("unknown command %s" % args.command)


def mongodb_firstboot(args):
    if os.path.exists(MONGODB_FIRSTBOOT_PATH):
        return
    ssl = ' --ssl' if args.ssl else ''
    call('mongo %s/admin %s %s' % (args.host, ssl, MONGODB_JS))
    with open(MONGODB_FIRSTBOOT_PATH, 'w') as f:
        f.write(NOW)


def mongodb_passwd(args):
    if not (args.user and args.password):
        raise ValueError("Invalid user: %s" % args.user)
    from metriqued.config import mongodb_config
    config = mongodb_config()
    ssl = ' --ssl' if config.ssl or args.ssl else ''
    old_pw = config.admin_password
    script = "db.changeUserPassword('%s', '%s')" % (args.user, args.password)
    call('mongo %s/admin %s --eval "%s" -u admin -p %s' % (args.host, ssl,
                                                           script, old_pw))


def mongodb_terminate(sig=None, frame=None):
    terminate(MONGODB_PIDFILE)
    sys.exit(2)


def mongodb(args):
    _fork = not args.nofork
    fork = '--fork' if _fork else ''

    if args.command == 'start':
        cmd = 'mongod -f %s %s' % (MONGODB_CONF, fork)
        cmd += ' --noprealloc --nojournal' if args.fast else ''
        call(cmd, fork=_fork, sig=signal.SIGTERM, sig_func=mongodb_terminate)
    elif args.command == 'stop':
        terminate(MONGODB_PIDFILE)
        args.command = 'clean'
        mongodb(args)
    elif args.command == 'restart':
        for cmd in ('stop', 'start'):
            args.command = cmd
            mongodb(args)
    elif args.command == 'clean':
        remove(MONGODB_LOCKFILE)
        remove(MONGODB_PIDFILE)
    elif args.command == 'trash':
        args.command = 'stop'
        mongodb(args)
        dest = os.path.join(TRASH_DIR, 'mongodb-%s' % NOW)
        shutil.move(MONGODB_DIR, dest)
        makedirs(MONGODB_DIR)
        remove(MONGODB_FIRSTBOOT_PATH)
    elif args.command == 'firstboot':
        mongodb_firstboot(args)
    elif args.command == 'status':
        call('mongod %s --sysinfo' % args.host)
    elif args.command == 'keyfile':
        call('openssl rand -base64 741 -out %s' % MONGODB_KEYFILE)
        os.chmod(MONGODB_KEYFILE, 0600)
    elif args.command == 'passwd':
        mongodb_passwd(args)
    else:
        raise ValueError("unknown command %s" % args.command)


def mongodb_rsync(args):
    from metriqued.config import mongodb_config
    config = mongodb_config()
    ssl = ' --ssl' if config.ssl else ''
    password = config.admin_password
    host = args.host or config.host.split(',')[0]  # first host listed
    target = MONGODB_DIR
    prefix = 'mongodb'
    saveas = '__'.join((prefix, HOSTNAME))
    ssh_user = args.ssh_user
    ssh_host = args.ssh_host

    js_islocked = 'printjson(db.currentOp().fsyncLock)'
    js_lock = 'db.fsyncLock()'
    js_unlock = 'db.fsyncUnlock()'

    # if mongodb is running, we'll need to sync and lock the db first
    running = get_pid(MONGODB_PIDFILE) != 0
    locked = False
    if running:
        locked = system(
            'mongo %s/admin %s --eval "%s" -u admin -p %s --quiet' % (
                host, ssl, js_islocked, password))
        locked = True if locked == 'true' else False

        if not locked:
            # sync and lock
            call('mongo %s/admin %s --eval "%s" -u admin -p %s' % (
                host, ssl, js_lock, password))
            locked = True

    call('rsync -az -e ssh %s %s@%s:%s' % (target, ssh_user, ssh_host, saveas))

    if running and locked:
        # unlock
        call('mongo %s/admin %s --eval "%s" -u admin -p %s' % (host, ssl,
                                                               js_unlock, password))


def mongodb_backup(args):
    from metriqued.config import mongodb_config
    config = mongodb_config()

    prefix = 'mongodb'
    saveas = '__'.join((prefix, HOSTNAME, NOW))
    out = os.path.join(BACKUP_DIR, saveas)

    host = config.host.split(',')[0]  # get the first host (expected primary)
    port = config.port
    p = config.admin_password
    password = '--password %s' % p if p else ''
    username = '--username %s' % config.admin_user if password else ''
    authdb = '--authenticationDatabase admin' if password else ''
    ssl = '--ssl' if config.ssl else ''

    cmd = ('mongodump', '--host %s' % host, '--port %s' % port,
           ssl, username, password, '--out %s' % out, authdb)
    cmd = ' '.join(cmd).replace('  ', ' ')
    call(cmd)

    saveas = out + '.tar.gz'
    backup(saveas, out)
    shutil.rmtree(out)

    backup_clean(args, BACKUP_DIR, 'mongodb')

    if args.scp_export:
        user = args.scp_user
        host = args.scp_host
        out_dir = args.scp_out_dir
        cmd = 'scp %s %s@%s:%s' % (saveas, user, host, out_dir)
        call(cmd)


def clean(args):
    # http://stackoverflow.com/a/785534/1289080
    os.system('find . -name "*.pyc" -exec rm -f {} \;')


def bump_version(regex, line, i, reset, **kwargs):
    # if we're bumping version, reset release to 1
    m = regex.match(line)
    if not m:
        raise ValueError(
            'Expected line matching __version__, got: %s' % line)
    current = m.groups()[0]
    current_parts = map(int, current.split('.'))
    if reset:
        current_parts[i] = 0
    else:
        current_parts[i] += 1
    bumped = '.'.join(map(str, current_parts))
    logger.info(' ... BUMP (VERSION) - %s->%s' % (current, bumped))
    return "__version__ = '%s'\n" % bumped


def bump_version_x(line, reset=False, **kwargs):
    return bump_version(RE_VERSION_X, line, 0, reset, **kwargs)


def bump_version_y(line, reset=False, **kwargs):
    return bump_version(RE_VERSION_Y, line, 1, reset, **kwargs)


def bump_version_z(line, reset=False, **kwargs):
    return bump_version(RE_VERSION_Z, line, 2, reset, **kwargs)


def bump_release(line, reset=False, ga=False):
    m = RE_RELEASE.match(line)
    if not m:
        raise ValueError(
            'Expected line matching __release__, got: %s' % line)
    current = int(m.groups()[1])
    if reset:
        bumped = 1
    else:
        bumped = current + 1  # bump by one

    if not ga:
        bumped = '"%sa"' % bumped
    else:
        # drop any 'a' if there is one
        bumped = re.sub('a$', '', str(bumped))

    logger.info(' ... BUMP (RELEASE): %s->%s' % (current, bumped))
    return '__release__ = %s\n' % bumped


def get_packages(args):
    global __pkgs__
    return [os.path.join(SRC_DIR, pkg) for pkg in __pkgs__]


def update_line(args, regex, bump_func):
    pkg_paths = get_packages(args)
    for path in pkg_paths:
        logger.info(path)
        path = '%s/setup.py' % path
        with open(path) as setup_py:
            content = setup_py.readlines()
            for i, line in enumerate(content):
                if regex.match(line):
                    content[i] = bump_func(line)
                else:
                    continue
                break  # stop after the first replace...
        if not content:
            raise ValueError(
                "content was empty; didn't want to overwrite...")
        elif None in content:
            raise RuntimeError(
                "check your nrv strings; "
                " they're missing our regex: \n%s" % regex.pattern)
        content_str = ''.join(content)
        # write out the new setup file with bumped
        with open(path, 'w') as setup_py:
            setup_py.write(content_str)


def setup(args, cmd, pip=False):
    global __pkgs__
    if isinstance(cmd, basestring):
        cmd = cmd.strip()
    else:
        cmd = ' '.join([s.strip() for s in cmd])
    for path in __pkgs__:
        abspath = os.path.join(SRC_DIR, path)
        os.chdir(abspath)
        if pip and args.slow:
            logger.info(system('pip %s -e %s' % (cmd, abspath)))
        elif pip:
            logger.info(system('pip-accel %s -e %s' % (cmd, abspath)))
        else:
            os.chdir(abspath)
            logger.info(system('python setup.py %s' % cmd))


def deploy(args):
    '''
    Order of Operations
    (NOT IN VIRTENV)
    + clone repo/pull branch
    + bump r
    + sdist upload
    (IN VIRTENV)
    + install dep
    + install metrique and friends
    '''
    # make sure we have the installer basics and their up2date
    # argparse is needed for py2.6; pip-accel caches compiled binaries
    # first run for a new virt-env will take forever...
    # second run should be 90% faster!
    virtenv = getattr(args, 'virtenv')
    if virtenv:
        # we can't be in a virtenv when running the virtualenv.main() script
        #sys.path = [p for p in sys.path if not p.startswith(virtenv)]
        deactivate()
        if args.trash:
            remove(args.virtenv)
        # virtualenv.main; pass in only the virtenv path
        sys.argv = sys.argv[0:1] + [virtenv]
        # run the virtualenv script to install the virtenv
        virtualenv.main()
        # activate the newly installed virtenv
        activate(args)

    call('pip install -U pip setuptools')
    call('pip install pip-accel')

    pip = 'pip' if args.slow else 'pip-accel'

    call('%s install -U argparse' % pip)

    # this required dep is installed separately b/c virtenv
    # path resolution issues; fails due to being unable to find
    # the python headers in the virtenv for some reason.
    call('%s install -U cython numpy pandas' % pip)

    # optional dependencies; highly recommended! but slow to
    # install if we're not testing
    if args.ipython:
        call('%s install -U ipython' % pip)
    if args.test or args.pytest:
        call('%s install -U pytest' % pip)
    if args.docs:
        call('%s install -U sphinx' % pip)
        # pip-accel fails to install this package...
        call('pip install -U sphinx_bootstrap_theme')
    if args.supervisord:
        call('%s install -U supervisor' % pip)

    cmd = 'install'
    no_pre = getattr(args, 'no_pre', False)
    if not no_pre:
        cmd += ' --pre'
    setup(args, cmd, pip=True)

    if args.develop:
        path = os.path.join(virtenv, 'lib/python2.7/site-packages/metrique*')
        mods = glob.glob(path)
        remove(mods)
        develop(args)

    # run py.test after install
    if args.test:
        for pkg in __pkgs__:
            call('py.test tests/%s' % pkg, cwd=GIT_DIR)


def bump(args, kind=None, reset=None):
    kind = kind or getattr(args, 'bump_kind', None) or 'r'
    reset = reset or getattr(args, 'reset', None)
    ga = getattr(args, 'ga', None)
    global __bumps__
    assert kind in __bumps__
    if kind == 'x':
        regex = RE_VERSION_X
        bump(args=args, kind='y', reset=True)
        bump_func = partial(bump_version_x, reset=reset)
    elif kind == 'y':
        regex = RE_VERSION_Y
        bump(args=args, kind='z', reset=True)
        bump_func = partial(bump_version_y, reset=reset)
    elif kind == 'z':
        regex = RE_VERSION_Z
        bump(args=args, kind='r', reset=True)
        bump_func = partial(bump_version_z, reset=reset)
    elif kind == 'r':
        regex = RE_RELEASE
        bump_func = partial(bump_release, reset=reset, ga=ga)
    update_line(args, regex, bump_func)


def build(args):
    cmd = 'build'
    setup(args, cmd)


def sdist(args, upload=None, bump_r=None):
    upload = upload or args.upload
    bump_r = bump_r or args.bump_r
    cmd = 'sdist'
    if upload:
        if bump_r:
            bump(args)
        cmd += ' upload'
    setup(args, cmd)


def develop(args):
    cmd = 'develop'
    setup(args, cmd)


def register(args):
    cmd = 'register'
    setup(args, cmd)


def status(path):
    pkg = os.path.basename(os.path.dirname(path))
    call('pip show %s' % pkg)


def ssl(args=None):
    logger.info("Generating self-signed SSL certificate + key + combined pem")
    call('openssl req -new -x509 -days 365 -nodes '
         '-out %s -keyout %s -batch' % (SSL_CERT, SSL_KEY))
    with open(SSL_PEM, 'w') as pem:
        with open(SSL_CERT) as cert:
            pem.write(''.join(cert.readlines()))
        with open(SSL_KEY) as key:
            pem.write(''.join(key.readlines()))


def rpms(args):
    if not os.path.exists(RPM_SYSTEM_RELEASE):
        raise OSError(
            "Non-RPM based host? Can't find %s" % RPM_SYSTEM_RELEASE)
    if USER != 'root':
        raise OSError("Must run this command as root, not %s" % USER)
    cmd = 'yum install -y %s' % ' '.join(RPMS)
    call(cmd, show_stdout=True)

def default_conf(path, template):
    if os.path.exists(path):
        path = '.'.join([path, 'default'])
    with open(path, 'w') as f:
        f.write(template)
    logger.info("Installed %s ..." % path)


def sys_firstboot(args=None):
    if os.path.exists(SYS_FIRSTBOOT_PATH):
        # skip if we have already run this before
        return

    # create default dirs in advance
    [makedirs(p) for p in (USER_DIR, PIP_CACHE_DIR, PIP_ACCEL_DIR,
                           PIP_EGGS, TRASH_DIR, LOG_DIR,
                           ETC_DIR, BACKUP_DIR, MONGODB_DIR,
                           CELERY_DIR, TEMP_DIR, CACHE_DIR,
                           GNUPG_DIR, PID_DIR)]

    # make sure the the default user python eggs dir is secure
    os.chmod(PIP_EGGS, 0700)

    # generate self-signed ssl certs
    ssl()

    # install default configuration files
    default_conf(METRIQUE_JSON, DEFAULT_METRIQUE_JSON)
    default_conf(METRIQUED_JSON, DEFAULT_METRIQUED_JSON)
    default_conf(MONGODB_JSON, DEFAULT_MONGODB_JSON)
    default_conf(MONGODB_CONF, DEFAULT_MONGODB_CONF)
    default_conf(MONGODB_JS, DEFAULT_MONGODB_JS)
    default_conf(CELERY_JSON, DEFAULT_CELERY_JSON)
    default_conf(NGINX_CONF, DEFAULT_NGINX_CONF)
    default_conf(SUPERVISORD_CONF, DEFAULT_SUPERVISORD_CONF)

    with open(SYS_FIRSTBOOT_PATH, 'w') as f:
        f.write(NOW)


def main():
    import argparse

    cli = argparse.ArgumentParser(description='Metrique Manage CLI')
    cli.add_argument('-V', '--virtenv')

    _sub = cli.add_subparsers(description='action')

    # Automated metrique deployment
    _deploy = _sub.add_parser('deploy')
    _deploy.add_argument(
        '--slow', action='store_true', help="don't use pip-accel")
    _deploy.add_argument(
        '--no-pre', action='store_true',
        help='ignore pre-release versions')
    _deploy.add_argument(
        '--develop', action='store_true', help='install in "develop mode"')
    _deploy.add_argument(
        '--test', action='store_true', help='run tests after deployment')
    _deploy.add_argument(
        '--ipython', action='store_true', help='install ipython')
    _deploy.add_argument(
        '--pytest', action='store_true', help='install pytest')
    _deploy.add_argument(
        '--docs', action='store_true', help='install doc utils')
    _deploy.add_argument(
        '--supervisord', action='store_true', help='install doc utils')
    _deploy.add_argument(
        '--trash', action='store_true', help='fresh install (rm old virtenv)')
    _deploy.set_defaults(func=deploy)

    # PIP standard build
    _build = _sub.add_parser('build')
    _build.set_defaults(func=build)

    # PIP sdist build
    _sdist = _sub.add_parser('sdist')
    _sdist.add_argument('-u', '--upload', action='store_true')
    _sdist.add_argument('-b', '--bump-r', action='store_true')
    _sdist.set_defaults(func=sdist)

    # PIP `develop` deployment
    _develop = _sub.add_parser('develop')
    _develop.set_defaults(func=develop)

    # PIP pkg register
    _register = _sub.add_parser('register')
    _register.set_defaults(func=register)

    # Bump metrique setup.py version/release
    _bump = _sub.add_parser('bump')
    _bump.add_argument('-k', '--bump-kind', choices=__bumps__)
    _bump.add_argument('-r', '--reset', choices=__bumps__)
    _bump.add_argument('-ga', action='store_true', dest='ga')
    _bump.set_defaults(func=bump)

    # PIP status
    _status = _sub.add_parser('status')
    _status.set_defaults(func=status)

    # Clean-up routines
    _clean = _sub.add_parser('clean')
    _clean.set_defaults(func=clean)

    # MongoDB Server
    _mongodb = _sub.add_parser('mongodb')
    _mongodb.add_argument('command',
                          choices=['start', 'stop', 'restart',
                                   'clean', 'trash', 'status',
                                   'keyfile', 'firstboot', 'passwd'])
    _mongodb.add_argument('-H', '--host', default='127.0.0.1')
    _mongodb.add_argument('-f', '--fast', action='store_true')
    _mongodb.add_argument('-s', '--ssl', action='store_true')
    _mongodb.add_argument('-u', '--user')
    _mongodb.add_argument('-p', '--password')
    _mongodb.add_argument('-F', '--nofork', action='store_true')
    _mongodb.set_defaults(func=mongodb)

    # MongoDB rsync
    _mongodb_rsync = _sub.add_parser('mongodb_rsync')
    _mongodb_rsync.add_argument('host', nargs='?')
    _mongodb_rsync.add_argument('-H', '--ssh-host')
    _mongodb_rsync.add_argument('-u', '--ssh-user', default='backup')
    _mongodb_rsync.set_defaults(func=mongodb_rsync)

    # MongoDB Backup
    _mongodb_backup = _sub.add_parser('mongodb_backup')
    _mongodb_backup.add_argument('-c', '--config-file')
    _mongodb_backup.add_argument('-k', '--keep', type=int, default=3)
    _mongodb_backup.add_argument('-x', '--scp-export', action='store_true')
    _mongodb_backup.add_argument('-H', '--scp-host')
    _mongodb_backup.add_argument('-u', '--scp-user', default='backup')
    _mongodb_backup.add_argument('-O', '--scp-out-dir')
    _mongodb_backup.set_defaults(func=mongodb_backup)

    # nginx Server
    _nginx = _sub.add_parser('nginx')
    _nginx.add_argument('command',
                        choices=['start', 'stop', 'reload',
                                 'restart', 'test'])
    _nginx.add_argument('-m', '--metriqued-config-file',
                        default=METRIQUED_JSON)
    _nginx.add_argument('-F', '--nofork', action='store_true')
    _nginx.set_defaults(func=nginx)

    # metriqued Server
    _metriqued = _sub.add_parser('metriqued')
    _metriqued.add_argument('command', choices=['start', 'stop', 'status',
                                                'firstboot'])
    _metriqued.add_argument('-c', '--server-config-file',
                            default=METRIQUED_JSON)
    _metriqued.add_argument('-P', '--port', type=int, default=5420)
    _metriqued.add_argument('-i', '--instances', type=int)
    _metriqued.add_argument('-s', '--signal', type=int)
    _metriqued.add_argument('-F', '--nofork', action='store_true')
    _metriqued.set_defaults(func=metriqued)

    # metriqued Backup
    _metriqued_backup = _sub.add_parser('metriqued_backup')
    _metriqued_backup.add_argument('-k', '--keep', type=int, default=3)
    _metriqued_backup.add_argument('-x', '--scp-export', action='store_true')
    _metriqued_backup.add_argument('-H', '--scp-host')
    _metriqued_backup.add_argument('-u', '--scp-user', default='backup')
    _metriqued_backup.add_argument('-O', '--scp-out-dir')
    _metriqued_backup.set_defaults(func=metriqued_backup)

    # celeryd task run
    _celeryd_task = _sub.add_parser('celeryd_task')
    _celeryd_task.add_argument('task')
    _celeryd_task.add_argument('--tasks-mod', default='dataservices.tasks')
    _celeryd_task.set_defaults(func=celeryd_task)

    # celeryd server
    _celeryd = _sub.add_parser('celeryd')
    _celeryd.add_argument('command', choices=['start', 'stop', 'clean'])
    _celeryd.add_argument('--tasks-mod', default='dataservices.tasks')
    _celeryd.add_argument('-F', '--nofork', action='store_true')
    _celeryd.set_defaults(func=celeryd)

    # celerybeat server
    _celerybeat = _sub.add_parser('celerybeat')
    _celerybeat.add_argument('command', choices=['start', 'stop', 'clean'])
    _celerybeat.add_argument('--tasks-mod', default='dataservices.tasks')
    _celerybeat.add_argument('-F', '--nofork', action='store_true')
    _celerybeat.set_defaults(func=celerybeat)

    # supervisord server
    _supervisord = _sub.add_parser('supervisord')
    _supervisord.add_argument('command', choices=['start', 'stop', 'clean'])
    _supervisord.set_defaults(func=supervisord)

    # SSL creation
    _ssl = _sub.add_parser('ssl')
    _ssl.set_defaults(func=ssl)

    # RPM Dependency Install
    _rpms = _sub.add_parser('rpms')
    _rpms.set_defaults(func=rpms)

    # parse argv
    args = cli.parse_args()

    # make sure we have some basic defaults configured in the environment
    sys_firstboot(args)

    # run command
    args.func(args)


if __name__ == '__main__':
    main()
